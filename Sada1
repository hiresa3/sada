import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import StreamingService from '../../../../../components/Web/Addons/redesign/StreamingDevice';
import {
  streamingDeviceProps,
  devicesProps,
  PropsAccessoryDetailsMoreThan3,
  streamingDevicePropsAccessoryDetails1,
  streamingDevice143line,
  streamingDevice197line,
  streamingDevice197lineQuantityDefined,
  streamingDevicePropsAccessoryDetails1sorIDGivenQuantityUndefined,
  accessoryDetails1andNoProductRefData,
  streamingDevicePropsAccessoryDetailsNewProps,
  streamingDevicePropsAccessoryDetailsNewProps1,
  PropsAccessoryDetailsMoreThan3NewProps,
  streamingDevice143lineDueMonthly,
  addonstestData,
} from './streamingDevicesTestData';
import { streamingDeviceConstants } from './constants';
import { spyFuncOn } from '../../../Common/jestCommon';

describe('StreamingService Component Tests', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  test('renders with default props and verifies heading', () => {
    render(<StreamingService {...streamingDeviceProps} />);
    const header = screen.getByText(streamingDeviceConstants.fiveGHeaderTextToCompare);
    expect(header).toBeInTheDocument();
  });

  test('renders correctly with no accessory details', () => {
    render(<StreamingService {...streamingDeviceProps} accessoryDetails={[]} />);
    const noAccessoriesMessage = screen.getByText('No accessories available');
    expect(noAccessoriesMessage).toBeInTheDocument();
  });

  test('displays correct header and subheader based on props', () => {
    render(<StreamingService {...streamingDeviceProps} />);
    const header = screen.getByText(streamingDeviceConstants.fiveGHeaderTextToCompare);
    const subheader = screen.getByText(streamingDeviceConstants.fiveGSubHeaderTextToCompare);
    expect(header).toBeInTheDocument();
    expect(subheader).toBeInTheDocument();
  });

  test('handles add to cart functionality', () => {
    const postAddToCartMock = jest.fn();
    render(
      <StreamingService
        {...streamingDeviceProps}
        postAddToCart={postAddToCartMock}
      />
    );
    const button = screen.getByRole('button', { name: 'Fire TV Cube Add to Cart' });
    fireEvent.click(button);
    expect(postAddToCartMock).toHaveBeenCalled();
  });

  test('handles remove from cart functionality', () => {
    const postRemoveFromCartMock = jest.fn();
    render(
      <StreamingService
        {...streamingDeviceProps}
        postRemoveCart={postRemoveFromCartMock}
      />
    );
    const button = screen.getByRole('button', { name: 'Fire TV Cube Remove' });
    fireEvent.click(button);
    expect(postRemoveFromCartMock).toHaveBeenCalled();
  });

  test('displays correct message when add to cart is successful', async () => {
    const showAddonNotificationMock = jest.fn();
    render(
      <StreamingService
        {...streamingDeviceProps}
        showAddonNotification={showAddonNotificationMock}
        notifyMessage="Added to cart"
      />
    );
    await waitFor(() => {
      expect(showAddonNotificationMock).toHaveBeenCalledWith('Added to cart');
    });
  });

  test('handles quantity changes for streaming services', () => {
    render(<StreamingService {...streamingDevice197lineQuantityDefined} />);
    const increaseButton = screen.getByRole('button', { name: 'Increase Stream TV by one' });
    const decreaseButton = screen.getByRole('button', { name: 'Decrease Stream TV by one' });
    fireEvent.click(increaseButton);
    fireEvent.click(decreaseButton);
    // Verify the result based on your implementation
  });

  test('renders correctly based on device type and flow type', () => {
    spyFuncOn(streamingDeviceConstants.getFlowTypeFuncName, streamingDeviceConstants.flowtype5G);
    render(<StreamingService {...streamingDeviceProps} />);
    const fiveGHeader = screen.getByText(streamingDeviceConstants.fiveGHeaderTextToCompare);
    expect(fiveGHeader).toBeInTheDocument();
  });

  test('displays correct information for tablet view', () => {
    spyFuncOn(streamingDeviceConstants.tabletTypeFuncName, streamingDeviceConstants.viewportFuncValueTablet);
    render(<StreamingService {...streamingDeviceProps} />);
    const tabletHeading = screen.getByText(streamingDeviceConstants.tabletHeadingTextToCompare);
    expect(tabletHeading).toBeInTheDocument();
  });

  test('verifies behavior with mobile view', () => {
    spyFuncOn(streamingDeviceConstants.mobileTypeFuncName, streamingDeviceConstants.viewportFuncValueMobile);
    render(<StreamingService {...streamingDeviceProps} />);
    const mobileHeader = screen.getByText(streamingDeviceConstants.mobileHeaderTextToCompare);
    expect(mobileHeader).toBeInTheDocument();
  });

  test('verifies rendering with multiple accessories', () => {
    render(<StreamingService {...PropsAccessoryDetailsMoreThan3} />);
    const accessories = screen.getAllByRole('button', { name: /Add to Cart/ });
    expect(accessories.length).toBeGreaterThan(3);
  });

  test('handles error cases for add to cart functionality', async () => {
    const postAddToCartMock = jest.fn(() => {
      throw new Error('Failed to add to cart');
    });
    render(
      <StreamingService
        {...streamingDeviceProps}
        postAddToCart={postAddToCartMock}
      />
    );
    const button = screen.getByRole('button', { name: 'Fire TV Cube Add to Cart' });
    fireEvent.click(button);
    await waitFor(() => {
      expect(postAddToCartMock).toThrow('Failed to add to cart');
    });
  });

  test('renders with different prop combinations', () => {
    render(<StreamingService {...streamingDevicePropsAccessoryDetailsNewProps} />);
    const element = screen.getByText(/Streaming Service/);
    expect(element).toBeInTheDocument();
  });

  // Add additional tests as needed for remaining scenarios and edge cases
});
